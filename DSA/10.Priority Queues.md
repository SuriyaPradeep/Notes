#queues #binary-heap #priority-queue
### What is Priority Queues

A priority queue is an abstract data type that behaves similarly to the normal queue except that each element has some priority, i.e., the element with the highest priority would come first in a priority queue. The priority of the elements in a priority queue will determine the order in which elements are removed from the priority queue.

The priority queue supports only comparable elements, which means that the elements are either arranged in an ascending or descending order.

For example, suppose we have some values like 1, 3, 4, 8, 14, 22 inserted in a priority queue with an ordering imposed on the values is from least to the greatest. Therefore, the 1 number would be having the highest priority while 22 will be having the lowest priority.

### Types of Priority Queue

**There are two types of priority queue:**

- **Ascending order priority queue:** In ascending order priority queue, a lower priority number is given as a higher priority in a priority. For example, we take the numbers from 1 to 5 arranged in an ascending order like 1,2,3,4,5; therefore, the smallest number, i.e., 1 is given as the highest priority in a priority queue.  
    ![Priority Queue](https://static.javatpoint.com/ds/images/ds-priority-queue.png)
- **Descending order priority queue:** In descending order priority queue, a higher priority number is given as a higher priority in a priority. For example, we take the numbers from 1 to 5 arranged in descending order like 5, 4, 3, 2, 1; therefore, the largest number, i.e., 5 is given as the highest priority in a priority queue.  
    ![Priority Queue](https://static.javatpoint.com/ds/images/ds-priority-queue2.png)

### Priority Queue Representation
#### Using Unordered Array
```java
package PriorityQueue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ArrayUnordered<T extends Comparable<T>> implements Iterable<T> {
    private  T[] pq;
    private  int size;
    public ArrayUnordered(){
        this.pq=(T[]) new Comparable[1];
    }
    private  void resize(int capacity){
        T[] cpyArr=(T[]) new Comparable[capacity];
        System.arraycopy(pq,0,cpyArr,0,size);
        pq=cpyArr;
    }
    private boolean isEmpty(){
        return size==0;
    }
    private int getSize(){
        return size;
    }
    private void enqueue(T a){
        if(size==pq.length){
            resize(pq.length*2);
        }
        pq[size++]=a;
    }
    private boolean less(T a, T b){
        return a.compareTo(b)<0;
    }
    private void swap(int i,int j){
        T temp=pq[i];
        pq[i]=pq[j];
        pq[j]=temp;
    }
    private T dequeue(){
        if(size==0){
            throw new NoSuchElementException("Queue is Empty");
        }
        int max=0;
        for(int i=0;i<size;i++){
            if(less(pq[max],pq[i])){
                max=i;
            }
        }
        swap(max,size-1);
        T item=pq[--size];
        if(size== pq.length/4){
            resize(pq.length/2);
        }
        return item;
    }
    public Iterator<T> iterator(){
        return new ArrayIterator();
    }
    private class ArrayIterator implements Iterator<T>{
        int i=0;
        public boolean hasNext(){
            return i<size;
        }
        public T next(){
            return pq[i++];
        }
    }
    public static void main(String[] args) {
        ArrayUnordered<Integer> pq=new ArrayUnordered<>();
        pq.enqueue(10);
        pq.enqueue(5);
        pq.enqueue(26);
        for(Integer x:pq){
            System.out.print(x+" ");
        }
        System.out.println();
        System.out.println(pq.dequeue());
       System.out.println(pq.dequeue());
       System.out.println(pq.dequeue());
    }
}
```

This Java class `ArrayUnordered` implements a priority queue using an unordered array. Let's go through each method and explain its purpose:

1. **Constructor `ArrayUnordered()`**:
    - Initializes the priority queue with an initial capacity of 1.
    - Creates an array `pq` of generic type `T` to hold the elements.
2. **Method `resize(int capacity)`**:
    - Resizes the internal array `pq` to the specified `capacity`.
    - Copies the existing elements to the new array.
3. **Method `isEmpty()`**:
    - Checks if the priority queue is empty.
    - Returns `true` if the size is 0, indicating an empty queue; otherwise, returns `false`.
4. **Method `getSize()`**:
    - Returns the current size of the priority queue.
5. **Method `enqueue(T a)`**:
    - Adds an element `a` to the priority queue.
    - If the queue is full, it resizes the array to double its current capacity before adding the element.
6. **Method `less(T a, T b)`**:
    - Compares two elements of type `T`.
    - Returns `true` if `a` is less than `b` based on their natural ordering; otherwise, returns `false`.
7. **Method `swap(int i, int j)`**:
    - Swaps the elements at indices `i` and `j` in the array `pq`.
8. **Method `dequeue()`**:
    - Removes and returns the maximum element from the priority queue.
    - It finds the maximum element by iterating through the array and keeping track of the index of the maximum element.
    - After removing the maximum element, it resizes the array if the size falls below 25% of its capacity to prevent excessive memory usage.
9. **Method `iterator()`**:
    - Returns an iterator over the elements of the priority queue.
10. **Class `ArrayIterator`** (private inner class):
    - Implements the `Iterator` interface for iterating over the elements of the priority queue.
    - Keeps track of the current index during iteration.
    - Provides `hasNext()` method to check if there are more elements to iterate over.
    - Provides `next()` method to return the next element during iteration.
11. **Method `main(String[] args)`**:
    - Demonstrates the functionality of the priority queue by enqueueing elements, iterating over them, and dequeuing them.
    - Prints the elements of the priority queue after enqueuing and dequeuing operations.

#### Using Ordered Array
```java
package PriorityQueue;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class ArrayOrdered<T extends Comparable<T>> implements Iterable<T> {
    private  T[] pq;
    private  int size;
    public ArrayOrdered(){
        this.pq=(T[]) new Comparable[1];
    }
    private  void resize(int capacity){
        T[] cpyArr=(T[]) new Comparable[capacity];
        System.arraycopy(pq,0,cpyArr,0,size);
        pq=cpyArr;
    }
    private boolean isEmpty(){
        return size==0;
    }
    private int getSize(){
        return size;
    }
    private boolean less(T a, T b){
        return a.compareTo(b)<0;
    }
    private T dequeue(){
        if(size==0){
            throw new NoSuchElementException("Queue is Empty");
        }
        T item= pq[--size];
        if(size== pq.length/4){
            resize(pq.length/2);
        }
        return item;
    }
    private void enqueue(T x){
        if(size== pq.length){
            resize(pq.length*2);
        }
        int i=size-1;
        while (i>=0 && less(x,pq[i])){
            pq[i+1]=pq[i];
            i--;
        }
        pq[i+1]=x;
        size++;
    }
    public Iterator<T> iterator(){
        return new ArrayIterator();
    }
    private class ArrayIterator implements Iterator<T>{
        int i=0;
        public boolean hasNext(){
            return i<size;
        }
        public T next(){
            return pq[i++];
        }
    }

    public static void main(String[] args) {
        ArrayOrdered<Integer> pq=new ArrayOrdered<>();
        pq.enqueue(10);
        pq.enqueue(5);
        pq.enqueue(26);
        pq.enqueue(35);
        for(Integer x:pq){
            System.out.print(x+" ");
        }
        System.out.println();
        System.out.println(pq.dequeue());
        System.out.println(pq.dequeue());
        System.out.println(pq.dequeue());
    }
}
```

This Java class `ArrayOrdered` implements a priority queue using an ordered array. Let's go through each method and explain its purpose:

1. **Constructor `ArrayOrdered()`**:
    - Initializes the priority queue with an initial capacity of 1.
    - Creates an array `pq` of generic type `T` to hold the elements.
2. **Method `resize(int capacity)`**:
    - Resizes the internal array `pq` to the specified `capacity`.
    - Copies the existing elements to the new array.
3. **Method `isEmpty()`**:
    - Checks if the priority queue is empty.
    - Returns `true` if the size is 0, indicating an empty queue; otherwise, returns `false`.
4. **Method `getSize()`**:
    - Returns the current size of the priority queue.
5. **Method `less(T a, T b)`**:
    - Compares two elements of type `T`.
    - Returns `true` if `a` is less than `b` based on their natural ordering; otherwise, returns `false`.
6. **Method `dequeue()`**:
    - Removes and returns the maximum element from the priority queue.
    - It removes the last element of the array and decreases the size.
    - It also checks if the size falls below 25% of its capacity and resizes the array accordingly to prevent excessive memory usage.
7. **Method `enqueue(T x)`**:
    - Adds an element `x` to the priority queue while maintaining the order.
    - If the queue is full, it resizes the array to double its current capacity before adding the element.
    - It finds the appropriate position for `x` in the array by shifting elements to the right until it finds the correct position based on the natural ordering.
    - It then inserts `x` at the correct position and increments the size.
8. **Method `iterator()`**:
    - Returns an iterator over the elements of the priority queue.
9. **Class `ArrayIterator`** (private inner class):
    - Implements the `Iterator` interface for iterating over the elements of the priority queue.
    - Keeps track of the current index during iteration.
    - Provides `hasNext()` method to check if there are more elements to iterate over.
    - Provides `next()` method to return the next element during iteration.
10. **Method `main(String[] args)`**:
    - Demonstrates the functionality of the priority queue by enqueueing elements, iterating over them, and dequeuing them.
    - Prints the elements of the priority queue after enqueuing and dequeuing operations.


#### Time Complexity
| Implementation | Enqueue | Dequeue | Max |
| ---- | ---- | ---- | ---- |
| Unordered | O(1) | O(N) | O(N) |
| Ordered | O(N) | O(1) | O(N) |
| Goal(Binary Heap) | O(log N) | O(log N) | O(log N) |

### Binary Heap
#### Introduction
A heap is a tree-based data structure that forms a complete binary tree, and satisfies the heap property. If A is a parent node of B, then A is ordered with respect to the node B for all nodes A and B in a heap. It means that the value of the parent node could be more than or equal to the value of the child node, or the value of the parent node could be less than or equal to the value of the child node. Therefore, we can say that there are two types of heaps:

- **Max heap:** The max heap is a heap in which the value of the parent node is greater than the value of the child nodes.  
    ![Priority Queue](https://static.javatpoint.com/ds/images/ds-priority-queue5.png)
- **Min heap:** The min heap is a heap in which the value of the parent node is less than the value of the child nodes.  
    ![Priority Queue](https://static.javatpoint.com/ds/images/ds-priority-queue6.png)

Both the heaps are the binary heap, as each has exactly two child nodes.

#### Heap Representation

![[Pasted image 20240219201220.png]]

A binary heap is typically represented as an array.
- The root element will be at `Arr[1]`. Leaving `Arr[0]` empty for easier calculation.
- The below table shows indices of other nodes for the ith node, i.e., `Arr[i]`:

| Indices|Access|
| ---- | ---- |
| Arr[(i)/2] | Returns the parent node |
| Arr[(2*i)] | Returns the left child node |
| Arr[(2*i)+1] | Returns the right child node |

If root Element is Selected in `Arr[0]` then the table will be like:

| Indices | Access |
| ---- | ---- |
| Arr[(i-1)/2] | Returns the parent node |
| Arr[(2*i)+1] | Returns the left child node |
| Arr[(2*i)+2] | Returns the right child node |
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/binaryheap.png)


#### Implementation
 **Max Implementation**
 ```java
 package BinaryHeap;


import java.util.Iterator;
import java.util.NoSuchElementException;

public class HeapArrayMax<T extends Comparable<T>> implements Iterable<T>{
    private T[] bh;
    private int size;
    public HeapArrayMax(){
        this.bh=(T[])new Comparable[2];
        this.size=0;
    }
    private int getSize(){
        return size;
    }
    private boolean isEmpty(){
        return size==0;
    }
    private void resize(int capacity){
        T[] cpyArr=(T[]) new Comparable[capacity];
        System.arraycopy(bh,1,cpyArr,1,size);
        bh=cpyArr;
    }
    private void swap(int i,int j){
        T temp=bh[i];
        bh[i]=bh[j];
        bh[j]=temp;
    }
    private boolean less(int a,int b){
        return bh[a].compareTo(bh[b])<0;
    }
    //K is key
    private void swim(int k){
        //Child's key becomes larger key than its parent's key.
        //If this condition is true exchange child and parent until order is maintained
        //Use while Insertion
        while (k>1 && less((k/2), k)) {//Parent less than child
            swap(k,k/2);//Swap parent and child
            k = k/2;//Make child pointer to parent index
        }
    }
    private void sink(int k){
        //Parent's key becomes smaller than one (or both) of its children's.
        // If condition is true then exchange parent with larger key in child of two repeat until order is maintained
        //Use while deletion
        while(2*k<=size){//Checks if child index is out of array or not
            int j=2*k;//Left child
            //Check Left or right Bigger
            if(j<size && less(j,j+1)){
                j++;
            }
            if(!less(k,j)){//Checks is the parent is larger than the child
                break;
            }
            swap(k,j);
            k=j;
        }
    }
    private void enqueue(T x){
        if(size==bh.length-1){
            resize(bh.length*2);
        }
        bh[++size]=x;
        swim(size);
    }
    private T dequeue(){
        if(isEmpty()){
            throw new NoSuchElementException("Queue is Empty");
        }
        T item=bh[1];
        swap(1,size--);
        sink(1);
        bh[size+1]=null;
        if(size>0 && size==(bh.length-1)/4){
            resize(bh.length/2);
        }
        return item;
    }
    //Check if the Array is Max Heap
    private boolean isMaxHeap(){
        //Checks if there is any null values in between values
        for (int i = 1; i <= size; i++) {
            if (bh[i] == null) return false;
        }
        //Checks if all the deleted values space are made null
        for (int i = size+1; i < bh.length; i++) {
            if (bh[i] != null) return false;
        }
        //Calls a Function to Check the order
        return isMaxHeapOrdered(1);
    }
    private boolean isMaxHeapOrdered(int k) {
        //It is a recursive function
        //Will return true if no error in ordering is found till k==size
        if (k > size) return true;
        //Checks if both child are smaller than the parent
        int left = 2*k;
        int right = 2*k + 1;
        if (left  <= size && less(k, left))  return false;
        if (right <= size && less(k, right)) return false;
        //Call the function recursively for the child's
        return isMaxHeapOrdered(left) && isMaxHeapOrdered(right);
    }
    public Iterator<T> iterator(){
        return new ArrayIterator();
    }
    private class ArrayIterator implements Iterator<T>{
        int i=1;
        public boolean hasNext(){
            return i<=size;
        }
        public T next(){
            return bh[i++];
        }
    }

    public static void main(String[] args) {
        HeapArrayMax<Integer> bh=new HeapArrayMax<>();
        bh.enqueue(10);
        bh.enqueue(5);
        bh.enqueue(26);
        bh.enqueue(35);
        for(int num:bh){
            System.out.print(num+" ");
        }
        System.out.println();
        System.out.println(bh.isMaxHeap());
        System.out.println(bh.dequeue());
        System.out.println(bh.dequeue());
        System.out.println(bh.dequeue());
        System.out.println(bh.dequeue());
        bh.enqueue(35);
        System.out.println(bh.dequeue());
    }
}
```

**Min Implementation**
```java
package BinaryHeap;

import java.util.Iterator;
import java.util.NoSuchElementException;

public class HeapArrayMin<T extends Comparable<T>> implements Iterable<T>{
    private T[] bh;
    private int size;
    public HeapArrayMin(){
        this.bh=(T[]) new Comparable[2];
        this.size=0;
    }
    private int getSize(){
        return size;
    }
    private boolean isEmpty(){
        return size==0;
    }
    private void resize(int capacity){
        T[] cpyArr=(T[]) new Comparable[capacity];
        System.arraycopy(bh,1,cpyArr,1,size);
        bh=cpyArr;
    }
    private void swap(int i,int j){
        T temp=bh[i];
        bh[i]=bh[j];
        bh[j]=temp;
    }
    private boolean greater(int i,int j){
        return bh[i].compareTo(bh[j])>0;
    }
    private void swim(int k){
        //Child's key becomes smaller key than its parent's key.
        //If this condition is true exchange child and parent until order is maintained
        //Use while Insertion
        while (k>1 && greater(k/2,k)){//Parent greater than child
            swap(k,k/2);//Swap parent and child
            k = k/2;//Make child pointer to parent index
        }
    }
    private void enqueue(T x){
        if(size==bh.length-1){
            resize(bh.length*2);
        }
        bh[++size]=x;
        swim(size);
    }
    private void sink(int k){
        //Parent's key becomes greater than one (or both) of its children's.
        //If condition is true then exchange parent with smaller key in child of two repeat until order is maintained
        //Use while deletion
        while (2*k<=size){//Checks if child index is out of array or not
            int j=2*k;//Left child
            //Check Left or right is smaller
            if(j<size && greater(j+1,j)){
                j++;
            }
            if(!greater(k,j)){//Checks is the parent is smaller than the child
                break;
            }
            swap(k,j);
            k=j;
        }
    }
    private T dequeue(){
        if(isEmpty()){
            throw new NoSuchElementException("Queue is Empty");
        }
        T item=bh[1];
        swap(1,size--);
        sink(1);
        bh[size+1]=null;
        if(size>0 && size==(bh.length-1)/4){
            resize(bh.length/2);
        }
        return item;
    }
    private boolean isMinHeap(){
        //Checks if there is any null values in between values
        for (int i = 1; i <= size; i++) {
            if (bh[i] == null) return false;
        }
        //Checks if all the deleted values space are made null
        for (int i = size+1; i < bh.length; i++) {
            if (bh[i] != null) return false;
        }
        //Calls a Function to Check the order
        return isMinHeapOrdered(1);
    }
    private boolean isMinHeapOrdered(int k) {
        //It is a recursive function
        //Will return true if no error in ordering is found till k==size
        if (k > size) return true;
        //Checks if both child are larger than the parent
        int left = 2*k;
        int right = 2*k + 1;
        if (left  <= size && greater(k, left))  return false;
        if (right <= size && greater(k, right)) return false;
        //Call the function recursively for the child's
        return isMinHeapOrdered(left) && isMinHeapOrdered(right);
    }
    public Iterator<T> iterator(){
        return new ArrayIterator();
    }
    private class ArrayIterator implements Iterator<T>{
        int i=1;
        public boolean hasNext(){
            return i<=size;
        }
        public T next(){
            return bh[i++];
        }
    }

    public static void main(String[] args) {
        HeapArrayMin<Integer> bh=new HeapArrayMin<>();
        bh.enqueue(10);
        bh.enqueue(5);
        bh.enqueue(26);
        bh.enqueue(35);
        for(int num:bh){
            System.out.print(num+" ");
        }
        System.out.println();
        System.out.println(bh.isMinHeap());
        System.out.println(bh.dequeue());
        System.out.println(bh.dequeue());
        System.out.println(bh.dequeue());
        System.out.println(bh.dequeue());
        bh.enqueue(32);
        bh.enqueue(0);
        System.out.println(bh.dequeue());
    }
}
```
#### Time Complexity
| Operations | Time Complexitu |
| ---- | ---- |
| Add | O(log N) |
| Remove | O(log N) |
| Finding Max or Min value | O(1) |