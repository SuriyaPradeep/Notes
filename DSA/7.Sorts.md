#sorting #bubble-sort #selection-sort #insertion-sort #shell-sort #merge-sort #quick-sort 
 #algorithm #stability #comparable #comparator #Dijkstras-Three-Pointer
### What is Sorting
Sorting is the process of arranging a collection of elements in a specific order. The goal of sorting is to organize the elements in a way that makes it easier to search, retrieve, and analyze the data.

### Bubble Sort

Bubble sort works on the repeatedly swapping of adjacent elements until they are not in the intended order.
**Algorithm for Bubble Sort**
```
begin BubbleSort(arr)  
   for all array elements  
      if arr[i] > arr[i+1]  
         swap(arr[i], arr[i+1])  
      end if  
   end for     
   return arr     
end BubbleSort  
```

#### Working
Let the elements of array are -

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm1.png)

##### First Pass

Sorting will start from the initial two elements. Let compare them to check which is greater.

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm2.png)

Here, 32 is greater than 13 (32 > 13), so it is already sorted. Now, compare 32 with 26.

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm3.png)

Here, 26 is smaller than 36. So, swapping is required. After swapping new array will look like -

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm4.png)

Now, compare 32 and 35.

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm5.png)

Here, 35 is greater than 32. So, there is no swapping required as they are already sorted.

Now, the comparison will be in between 35 and 10.

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm6.png)

Here, 10 is smaller than 35 that are not sorted. So, swapping is required. Now, we reach at the end of the array. After first pass, the array will be -

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm7.png)

Now, move to the second iteration.

##### Second Pass

The same process will be followed for second iteration.

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm8.png)

Here, 10 is smaller than 32. So, swapping is required. After swapping, the array will be -

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm9.png)

Now, move to the third iteration.

##### Third Pass

The same process will be followed for third iteration.

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm10.png)

Here, 10 is smaller than 26. So, swapping is required. After swapping, the array will be -

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm11.png)

Now, move to the fourth iteration.

##### Fourth pass

Similarly, after the fourth iteration, the array will be -

![Bubble sort Algorithm](https://static.javatpoint.com/ds/images/bubble-sort-algorithm12.png)

Hence, there is no swapping required, so the array is completely sorted.


#### Implementation
```java
package Sort;

import java.util.Arrays;

public class BubbleSort {
    /*The <T extends Comparable<T>> syntax in the method signatures indicates that the generic type T must extend
    the Comparable<T> interface, ensuring type safety.*/
    private static <T extends Comparable<T>> void swap(T[] arr, int i, int j){
        T temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
    private static <T extends Comparable<T>> boolean less(T a,T b){
        return a.compareTo(b)<0;
    }
    private static <T extends Comparable<T>> boolean isSorted(T[] arr){
        for(int i=1;i< arr.length;i++){
            if(less(arr[i],arr[i-1])){
                return false;
            }
        }
        return true;
    }
    public static <T extends Comparable<T>> void sort(T[] arr){
        int n=arr.length;
        boolean swap=false;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(less(arr[j],arr[i])){
                    swap(arr,i,j);
                    swap=true;
                }
            }
            if (!swap){
                System.out.println("Array is Sorted");
                break;
            }
        }
    }

    public static void main(String[] args) {
        Integer[] arr={10,5,1,4,3,2};
        sort(arr);
        System.out.println(isSorted(arr));
        System.out.println(Arrays.toString(arr));
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        sort(stringArr);
        System.out.println(isSorted(stringArr));
        System.out.println(Arrays.toString(stringArr));
        Integer[] arr_sorted={1,2,3,4,5,6,7,8,9,10};
        sort(arr_sorted);
        System.out.println(Arrays.toString(arr_sorted));
    }
}
```

The Above code is generic i.e. it can be used to sort any type of data using `Comparable` interface.The `Comparable` interface in Java is used to define the natural ordering of objects. Objects that implement the `Comparable` interface can be compared with each other, and the natural order of the objects is determined by the implementation of the `compareTo` method.
The`compareTo` method returns an integer value that indicates the relationship between the two objects being compared.  
Specifically:  
If the current object is less than the specified object, `compareTo` returns a negative integer.  
If the current object is equal to the specified object, `compareTo` returns 0.  
If the current object is greater than the specified object,` compareTo` returns a positive integer.
The `<T extends Comparable<T>>` syntax in the method signatures indicates that the generic type `T` must extend the `Comparable<T>` interface, ensuring type safety.


**swap**
```java
private static <T extends Comparable<T>> void swap(T[] arr, int i, int j) {
    T temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
```
This function is responsible for swapping two elements in an array. It takes an array `arr` and two indices `i` and `j`. The elements at indices `i` and `j` are exchanged.

**less**
```java
private static <T extends Comparable<T>> boolean less(T a, T b) {
    return a.compareTo(b) < 0;
}
```
This function compares two elements (a and b) using their compareTo method. It returns true if element a is less than element b, indicating that they are in the wrong order.

**isSorted**
```java
private static <T extends Comparable<T>> boolean isSorted(T[] arr) {
    for (int i = 1; i < arr.length; i++) {
        if (less(arr[i], arr[i - 1])) {
            return false;
        }
    }
    return true;
}
```
The `isSorted` function checks if an array is sorted in ascending order. It iterates through the array and uses the `less` function to compare adjacent elements. If any adjacent elements are out of order, the function returns `false`. If the entire array is traversed without finding any out-of-order elements, it returns `true`.

**sort**
```java
public static <T extends Comparable<T>> void sort(T[] arr){
        int n=arr.length;
        boolean swap=false;
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(less(arr[j],arr[i])){
                    swap(arr,i,j);
                    swap=true;
                }
            }
            if (!swap){
                System.out.println("Array is Sorted");
                break;
            }
        }
    }
```
The `sort` function implements the Bubble Sort algorithm. It takes an array `arr` of generic type `T` and sorts it in ascending order. The nested loops iterate through the array, and if an element at position `j` is less than the element at position `i`, it swaps them using the `swap` function. If there is no swapping of array elements in first iteration it means array is already sorted and breaks the loop. 


#### Time Complexity

|Case|Time Complexity|
|---|---|
|**Best Case**|O(n) |
|**Average Case**|O(n2)|
|**Worst Case**|O(n2)|
### Selection Sort
In selection sort, the smallest value among the unsorted elements of the array is selected in every pass and inserted to its appropriate position into the array. In selection sort, the first smallest element is selected from the unsorted array and placed at the first position. After that second smallest element is selected and placed in the second position. The process continues until the array is entirely sorted.

**Algorithm**
```j
SELECTION SORT(arr, n)  
  
Step 1: Repeat Steps 2 and 3 for i = 0 to n-1  
Step 2: CALL SMALLEST(arr, i, n, pos)  
Step 3: SWAP arr[i] with arr[pos]  
[END OF LOOP]  
Step 4: EXIT  
  
SMALLEST (arr, i, n, pos)  
Step 1: [INITIALIZE] SET SMALL = arr[i]  
Step 2: [INITIALIZE] SET pos = i  
Step 3: Repeat for j = i+1 to n  
if (SMALL > arr[j])  
     SET SMALL = arr[j]  
SET pos = j  
[END OF if]  
[END OF LOOP]  
Step 4: RETURN pos  
```

#### Working
Now, let's see the working of the Selection sort Algorithm.

To understand the working of the Selection sort algorithm, let's take an unsorted array. It will be easier to understand the Selection sort via an example.

Let the elements of array are -

![selection Sort Algorithm](https://static.javatpoint.com/ds/images/selection-sort.png)

Now, for the first position in the sorted array, the entire array is to be scanned sequentially.

At present, **12** is stored at the first position, after searching the entire array, it is found that **8** is the smallest value.

![selection Sort Algorithm](https://static.javatpoint.com/ds/images/selection-sort2.png)

So, swap 12 with 8. After the first iteration, 8 will appear at the first position in the sorted array.

![selection Sort Algorithm](https://static.javatpoint.com/ds/images/selection-sort3.png)

For the second position, where 29 is stored presently, we again sequentially scan the rest of the items of unsorted array. After scanning, we find that 12 is the second lowest element in the array that should be appeared at second position.

![selection Sort Algorithm](https://static.javatpoint.com/ds/images/selection-sort4.png)

Now, swap 29 with 12. After the second iteration, 12 will appear at the second position in the sorted array. So, after two iterations, the two smallest values are placed at the beginning in a sorted way.

![selection Sort Algorithm](https://static.javatpoint.com/ds/images/selection-sort5.png)

The same process is applied to the rest of the array elements. Now, we are showing a pictorial representation of the entire sorting process.

![selection Sort Algorithm](https://static.javatpoint.com/ds/images/selection-sort6.png)

Now, the array is completely sorted.
#### Implementation
```java
package Sort;

import java.util.Arrays;


public class SelectionSort  {
    private static <T extends Comparable<T>>boolean less(T v, T w) {
        return v.compareTo(w) < 0;
        /*The compareTo method is a method defined in the Comparable interface in Java.
        It is used to compare two objects for the purpose of sorting.
        The method returns an integer value that indicates the relationship between the two objects being compared.
        Specifically:
        If the current object is less than the specified object, compareTo returns a negative integer.
        If the current object is equal to the specified object, compareTo returns 0.
        If the current object is greater than the specified object, compareTo returns a positive integer.*/
    }
    private static <T extends Comparable<T>> void swap(T[] a, int i, int j)
    {
        T swap = a[i];
        a[i] = a[j];
        a[j] = swap;
    }
    private static <T extends Comparable<T>> boolean isSorted(T[] a)
    {
        for (int i = 1; i < a.length; i++)
            if (less(a[i], a[i-1])) return false;
        return true;
    }
    public static <T extends Comparable<T>> void sort(T[] a)
    {
        int N = a.length;
        for (int i = 0; i < N; i++)
        {
            int min = i;
            for (int j = i+1; j < N; j++)
                if (less(a[j], a[min]))
                    min = j;
            swap(a, i, min);
        }
    }
    public static void main(String[] args) {
        Integer[] arr={10,5,1,4,3,2};
        sort(arr);
        System.out.println(isSorted(arr));
        System.out.println(Arrays.toString(arr));
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        sort(stringArr);
        System.out.println(isSorted(stringArr));
        System.out.println(Arrays.toString(stringArr));
    }
}
```

**sort**
```java
public static <T extends Comparable<T>> void sort(T[] a) {
    int N = a.length;
    for (int i = 0; i < N; i++) {
        int min = i;
        for (int j = i + 1; j < N; j++)
            if (less(a[j], a[min]))
                min = j;
        swap(a, i, min);
    }
}
```

The `sort` method is responsible for sorting an array `a` of generic type `T` using the Selection Sort algorithm.

1. **Outer Loop (`for i`):**
    - The outer loop (`for i`) iterates through the array from the beginning to the end.
    - It considers each element as a potential starting point of the sorted portion.
2. **Inner Loop (`for j`):**
    - The inner loop (`for j`) starts from the element after the current position of the outer loop (`i`).
    - It searches for the minimum element in the unsorted portion of the array.
3. **Finding the Minimum Element:**
    - The variable `min` keeps track of the index of the minimum element found so far.
    - If an element at position `j` is less than the element at position `min`, update `min` to `j`.
    - After completing the inner loop, the index `min` points to the minimum element in the unsorted portion.
4. **Swapping:**
    - Swap the element at the current position of the outer loop (`i`) with the minimum element found (`a[min]`).
    - This effectively moves the minimum element to its correct sorted position.
5. **Repeat:**
    - Repeat the process until the entire array is sorted.


#### Time Complexity

|Case|Time Complexity|
|---|---|
|**Best Case**|O(n2) |
|**Average Case**|O(n2)|
|**Worst Case**|O(n2)|
### Insertion Sort
Insertion sort works similar to the sorting of playing cards in hands. It is assumed that the first card is already sorted in the card game, and then we select an unsorted card. If the selected unsorted card is greater than the first card, it will be placed at the right side; otherwise, it will be placed at the left side. Similarly, all unsorted cards are taken and put in their exact place.

**Algorithm**
```
Step 1 - If the element is the first element, assume that it is already sorted. Return 1.

Step2 - Pick the next element, and store it separately in a key.

Step3 - Now, compare the key with all elements in the sorted array.

Step 4 - If the element in the sorted array is smaller than the current element, then move to the next element. Else, shift greater elements in the array towards the right.

Step 5 - Insert the value.

Step 6 - Repeat until the array is sorted.
```

#### Working
Now, let's see the working of the insertion sort Algorithm.

To understand the working of the insertion sort algorithm, let's take an unsorted array. It will be easier to understand the insertion sort via an example.

Let the elements of array are -

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort.png)

Initially, the first two elements are compared in insertion sort.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort2.png)

Here, 31 is greater than 12. That means both elements are already in ascending order. So, for now, 12 is stored in a sorted sub-array.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort3.png)

Now, move to the next two elements and compare them.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort4.png)

Here, 25 is smaller than 31. So, 31 is not at correct position. Now, swap 31 with 25. Along with swapping, insertion sort will also check it with all elements in the sorted array.

For now, the sorted array has only one element, i.e. 12. So, 25 is greater than 12. Hence, the sorted array remains sorted after swapping.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort5.png)

Now, two elements in the sorted array are 12 and 25. Move forward to the next elements that are 31 and 8.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort6.png)

Both 31 and 8 are not sorted. So, swap them.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort7.png)

After swapping, elements 25 and 8 are unsorted.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort8.png)

So, swap them.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort9.png)

Now, elements 12 and 8 are unsorted.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort10.png)

So, swap them too.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort11.png)

Now, the sorted array has three items that are 8, 12 and 25. Move to the next items that are 31 and 32.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort12.png)

Hence, they are already sorted. Now, the sorted array includes 8, 12, 25 and 31.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort13.png)

Move to the next elements that are 32 and 17.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort14.png)

17 is smaller than 32. So, swap them.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort15.png)

Swapping makes 31 and 17 unsorted. So, swap them too.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort16.png)

Now, swapping makes 25 and 17 unsorted. So, perform swapping again.

![Insertion Sort Algorithm](https://static.javatpoint.com/ds/images/insertion-sort17.png)

Now, the array is completely sorted.



#### Implementation
```java
package Sort;

import java.util.Arrays;

public class InsertionSort {
    private static <T extends Comparable<T>> void swap(T[] arr, int i, int j){
        T temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
    private static <T extends Comparable<T>> boolean less(T a,T b){
        return a.compareTo(b)<0;
    }
    private static <T extends Comparable<T>> boolean isSorted(T[] arr){
        for(int i=1;i< arr.length;i++){
            if(less(arr[i],arr[i-1])){
                return false;
            }
        }
        return true;
    }
    public static <T extends Comparable<T>> void sort(T[] arr){
        for(int i=0;i< arr.length;i++){
            for (int j=i;j>0;j--){
                if(less(arr[j],arr[j-1])){
                    swap(arr,j,j-1);
                } else{
                    break;
                }
            }
        }
    }

    public static void main(String[] args) {
        Integer[] arr={10,5,1,4,3,2};
        sort(arr);
        System.out.println(isSorted(arr));
        System.out.println(Arrays.toString(arr));
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        sort(stringArr);
        System.out.println(isSorted(stringArr));
        System.out.println(Arrays.toString(stringArr));
    }
}
```

**sort**
```java
public static <T extends Comparable<T>> void sort(T[] arr) {
    for (int i = 1; i < arr.length; i++) {
        for (int j = i; j > 0; j--) {
            if (less(arr[j], arr[j - 1])) {
                swap(arr, j, j - 1);
            } else {
                break;
            }
        }
    }
}
```
Insertion Sort is a simple sorting algorithm that builds the final sorted array one element at a time. It is efficient for small datasets or partially sorted datasets.

1. **Outer Loop (`for i`):**
    - The outer loop (`for i`) starts from the second element (`i=1`) and iterates through the entire array.
    - It considers each element as the key to be inserted into the already sorted portion.
2. **Inner Loop (`for j`):**
    - The inner loop (`for j`) starts from the current position of the outer loop (`i`) and goes backward.
    - It compares the key element with the elements in the sorted portion, moving larger elements to the right.
3. **Insertion:**
    - The key element is repeatedly compared with the elements in the sorted portion until a smaller or equal element is found.
    - The key element is then inserted at the correct position in the sorted portion.
4. **Repeat:**
    - Steps 1-3 are repeated for each element in the array, effectively building the final sorted array.
#### Time Complexity

|Case|Time Complexity|
|---|---|
|**Best Case**|O(n) |
|**Average Case**|O(n2)|
|**Worst Case**|O(n2)|

### Shell Sort
It is a sorting algorithm that is an extended version of insertion sort. Shell sort has improved the average time complexity of insertion sort. As similar to insertion sort, it is a comparison-based and in-place sorting algorithm. Shell sort is efficient for medium-sized data sets.

In insertion sort, at a time, elements can be moved ahead by one position only. To move an element to a far-away position, many movements are required that increase the algorithm's execution time. But shell sort overcomes this drawback of insertion sort. It allows the movement and swapping of far-away elements as well.

This algorithm first sorts the elements that are far away from each other, then it subsequently reduces the gap between them. This gap is called as **interval.** This interval can be calculated by using the **Knuth's** formula given below -
```
hh = h * 3 + 1  
where, 'h' is the interval having initial value 1.
```
**Algorithm**
```
ShellSort(a, n) // 'a' is the given array, 'n' is the size of array  
for (interval = n/2; interval > 0; interval /= 2)  
for ( i = interval; i < n; i += 1)  
temp = a[i];  
for (j = i; j >= interval && a[j - interval] > temp; j -= interval)  
a[j] = a[j - interval];   
a[j] = temp;  
End ShellSort  
```
#### Working
Now, let's see the working of the shell sort Algorithm.

To understand the working of the shell sort algorithm, let's take an unsorted array. It will be easier to understand the shell sort via an example.

Let the elements of array are -

![Shell Sort Algorithm](https://static.javatpoint.com/ds/images/shell-sort-algorithm1.png)

We will use the original sequence of shell sort, i.e., N/2, N/4,....,1 as the intervals.

In the first loop, n is equal to 8 (size of the array), so the elements are lying at the interval of 4 (n/2 = 4). Elements will be compared and swapped if they are not in order.

Here, in the first loop, the element at the 0th position will be compared with the element at 4th position. If the 0th element is greater, it will be swapped with the element at 4th position. Otherwise, it remains the same. This process will continue for the remaining elements.

At the interval of 4, the sublists are {33, 12}, {31, 17}, {40, 25}, {8, 42}.

![Shell Sort Algorithm](https://static.javatpoint.com/ds/images/shell-sort-algorithm2.png)

Now, we have to compare the values in every sub-list. After comparing, we have to swap them if required in the original array. After comparing and swapping, the updated array will look as follows -

![Shell Sort Algorithm](https://static.javatpoint.com/ds/images/shell-sort-algorithm3.png)

In the second loop, elements are lying at the interval of 2 (n/4 = 2), where n = 8.

Now, we are taking the interval of **2** to sort the rest of the array. With an interval of 2, two sublists will be generated - {12, 25, 33, 40}, and {17, 8, 31, 42}.

![Shell Sort Algorithm](https://static.javatpoint.com/ds/images/shell-sort-algorithm4.png)

Now, we again have to compare the values in every sub-list. After comparing, we have to swap them if required in the original array. After comparing and swapping, the updated array will look as follows -

![Shell Sort Algorithm](https://static.javatpoint.com/ds/images/shell-sort-algorithm5.png)

In the third loop, elements are lying at the interval of 1 (n/8 = 1), where n = 8. At last, we use the interval of value 1 to sort the rest of the array elements. In this step, shell sort uses insertion sort to sort the array elements.

![Shell Sort Algorithm](https://static.javatpoint.com/ds/images/shell-sort-algorithm6.png)

Now, the array is sorted in ascending order.

#### Implementation
```java
package Sort;

import java.util.Arrays;

public class ShellSort {
    private static <T extends Comparable<T>> void swap(T[] arr, int i, int j){
        T temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
    private static <T extends Comparable<T>> boolean less(T a,T b){
        return a.compareTo(b)<0;
    }
    private static <T extends Comparable<T>> boolean isSorted(T[] arr){
        for(int i=1;i< arr.length;i++){
            if(less(arr[i],arr[i-1])){
                return false;
            }
        }
        return true;
    }
    public static  <T extends Comparable<T>> void sort(T[] arr){
        int n=arr.length;
        int h=1;
        while(h<n/3){
            h=3*h+1;
        }
        while(h>=1){
            for(int i=h;i<n;i++){
                for(int j=i;j>=h && less(arr[j],arr[j-h]);j-=h){
                    swap(arr,j,j-h);
                }
            }
            h=h/3;
        }
    }

    public static void main(String[] args) {
        Integer[] arr={10,5,1,4,3,2};
        sort(arr);
        System.out.println(isSorted(arr));
        System.out.println(Arrays.toString(arr));
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        sort(stringArr);
        System.out.println(isSorted(stringArr));
        System.out.println(Arrays.toString(stringArr));
    }
}
```

**sort**
1. **Choose Initial Gap (`h`):**
    - The algorithm starts by choosing an initial value for the gap (`h`). Here, the choice is based on the 3x+1 increment sequence.
    - The while loop calculates the initial value of `h` until it exceeds one-third of the array size (`n`).
2. **Gap Sequence:**
    - The gap sequence is crucial for the efficiency of Shell Sort. The 3x+1 sequence (1, 4, 13, 40, ...) is a common choice.
3. **Main Sorting Loop:**
    - The outer loop iterates over decreasing values of `h`, reducing it from the initial value toward 1.
    - For each value of `h`, the algorithm performs an Insertion Sort pass on the array.
4. **Insertion Sort with Gap:**
    - The inner loop iterates over the array, starting from `h`.
    - It compares and swaps elements that are `h` positions apart, effectively sorting subarrays.
5. **Reducing Gap:**
    - After completing the Insertion Sort pass with the current gap value, the gap (`h`) is reduced for the next iteration.


#### Time Complexity

|Case|Time Complexity|
|---|---|
|**Best Case**|O(n log n) |
|**Average Case**|O(n log n) |
|**Worst Case**|O(n^(3/2)) |

### Merge Sort
Merge sort is the sorting technique that follows the divide and conquer approach. Merge sort is similar to the quick sort algorithm as it uses the divide and conquer approach to sort the elements. It is one of the most popular and efficient sorting algorithm. It divides the given list into two equal halves, calls itself for the two halves and then merges the two sorted halves. We have to define the **merge()** function to perform the merging. The sub-lists are divided again and again into halves until the list cannot be divided further. Then we combine the pair of one element lists into two-element lists, sorting them in the process. The sorted two-element pairs is merged into the four-element lists, and so on until we get the sorted list.

**Algorithm**
```
MERGE_SORT(arr, beg, end)  
  
if beg < end  
set mid = (beg + end)/2  
MERGE_SORT(arr, beg, mid)  
MERGE_SORT(arr, mid + 1, end)  
MERGE (arr, beg, mid, end)  
end of if  
  
END MERGE_SORT  
```


#### Working
Now, let's see the working of merge sort Algorithm.

To understand the working of the merge sort algorithm, let's take an unsorted array. It will be easier to understand the merge sort via an example.

Let the elements of array are -

![Merge sort](https://static.javatpoint.com/ds/images/merge-sort.png)

According to the merge sort, first divide the given array into two equal halves. Merge sort keeps dividing the list into equal parts until it cannot be further divided.

As there are eight elements in the given array, so it is divided into two arrays of size 4.

![Merge sort](https://static.javatpoint.com/ds/images/merge-sort2.png)

Now, again divide these two arrays into halves. As they are of size 4, so divide them into new arrays of size 2.

![Merge sort](https://static.javatpoint.com/ds/images/merge-sort3.png)

Now, again divide these arrays to get the atomic value that cannot be further divided.

![Merge sort](https://static.javatpoint.com/ds/images/merge-sort4.png)

Now, combine them in the same manner they were broken.

In combining, first compare the element of each array and then combine them into another array in sorted order.

So, first compare 12 and 31, both are in sorted positions. Then compare 25 and 8, and in the list of two values, put 8 first followed by 25. Then compare 32 and 17, sort them and put 17 first followed by 32. After that, compare 40 and 42, and place them sequentially.

![Merge sort](https://static.javatpoint.com/ds/images/merge-sort5.png)

In the next iteration of combining, now compare the arrays with two data values and merge them into an array of found values in sorted order.

![Merge sort](https://static.javatpoint.com/ds/images/merge-sort6.png)

Now, there is a final merging of the arrays. After the final merging of above arrays, the array will look like -

![Merge sort](https://static.javatpoint.com/ds/images/merge-sort7.png)

Now, the array is completely sorted.
#### Implementation
Merge sort can be implemented either Top-Down (recursive) or Bottom-up.

##### Top-Down:
Top down  is a recursive mergesort implementation based on this abstract in-place merge. It is one of the best-known examples of the utility of the _divide-and-conquer_ paradigm for efficient algorithm design

![](https://algs4.cs.princeton.edu/22mergesort/images/mergesortTD.png)

```java
package Sort;

import java.util.Arrays;

public class MergeSort<T extends Comparable<T>> {
    //To compare 2 elements
    private boolean isLess(T a, T b){
        return a.compareTo(b)<0;
    }
    //To check is array is sorted
    private  boolean isSorted(T[] arr){
        boolean sorted=true;
        for(int i=1;i< arr.length;i++){
            if(isLess(arr[i],arr[i-1])){
               sorted=false;
               break;
            }
        }
        return sorted;
    }
    //Sort function to enter beg and end
    public void sort(T[] arr){
        if(arr==null || arr.length<=1){
            return;
        }
        mergerSort(arr,0,arr.length-1);
    }
    //To merge two sub-array in sorted manner
   public void merge(T[] arr,int beg,int mid,int end){
        //Size of 2 arrays
       int n1=mid-beg+1;
       int n2=end-mid;
       //Creating and copying elements to aux arrays
       T[] left=Arrays.copyOfRange(arr,beg,mid+1);
       T[] right=Arrays.copyOfRange(arr,mid+1,end+1);
       // Merging the array
       int i=0,j=0,k=beg;
       //i left array pointer, j right array pointer, k main array pointer
       while(i<n1 && j<n2){
           if(isLess(right[j],left[i])){
               arr[k++]=right[j++];
           }else{
               arr[k++]=left[i++];
           }
       }
       //Copy remaining elements
       while(i<n1){
           arr[k++]=left[i++];
       }
       while(j<n2){
           arr[k++]=right[j++];
       }
   }
   public void mergerSort(T[] arr,int beg,int end){
	   //Checks for base condition
        if(beg<end){
            int mid=(beg+end)/2;
            mergerSort(arr,beg,mid);
            mergerSort(arr,mid+1,end);
            merge(arr,beg,mid,end);
        }
   }
    
    // Main method to test the MergeSort class
    public static void main(String[] args) {
        Integer[] arr = {12, 11, 13, 5, 6, 7};
        MergeSort<Integer> ms1 = new MergeSort<>();
        System.out.println(ms1.isSorted(arr));
        ms1.sort(arr);
        System.out.println(Arrays.toString(arr));
        System.out.println(ms1.isSorted(arr));
        MergeSort<String> ms2 = new MergeSort<>();
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        System.out.println(ms2.isSorted(stringArr));
        ms2.sort(stringArr);
        System.out.println(Arrays.toString(stringArr));
        System.out.println(ms2.isSorted(stringArr));
    }
}
```

Let's walk through the `mergeSort` function with an example array and see how it works step by step.

Suppose we have an array: 12,11,13,5,6,7
We want to sort this array using merge sort.

1. **Initial Call**:
    - `mergeSort(arr, 0, arr.length - 1)`, which translates to `mergeSort(arr, 0, 5)`.
2. **Recursive Calls**:
    - Since `beg < end`, we proceed to divide the array.
    - Calculate `mid = (0 + 5) / 2 = 2`.
    - Recursively call `mergeSort(arr, 0, 2)` for the left half and `mergeSort(arr, 3, 5)` for the right half.
3. **Left Half (mergeSort(arr, 0, 2))**:
    - Calculate `mid = (0 + 2) / 2 = 1`.
    - Recursively call `mergeSort(arr, 0, 1)` for the left half and `mergeSort(arr, 2, 2)` for the right half.
4. **Left Half (mergeSort(arr, 0, 1))**:
    - Since `beg < end`, we proceed to divide the array.
    - Calculate `mid = (0 + 1) / 2 = 0`.
    - Recursively call `mergeSort(arr, 0, 0)` for the left half and `mergeSort(arr, 1, 1)` for the right half.
5. **Left Half (mergeSort(arr, 0, 0))**:
    - Since `beg < end` is false, no action is taken.
6. **Right Half (mergeSort(arr, 1, 1))**:
    - Since `beg < end` is false, no action is taken.
7. **Merge (merge(arr, 0, 0, 1))**:
    - The left half `[12]` and right half `[11]` are merged into sorted order: `[11, 12]`.
8. **Right Half (mergeSort(arr, 2, 2))**:
    - Since `beg < end` is false, no action is taken.
9. **Merge (merge(arr, 0, 1, 2))**:
    - The previously sorted left half `[11, 12]` and right half `[13]` are merged into sorted order: `[11, 12, 13]`.
10. **Right Half (mergeSort(arr, 3, 5))**:
	- Calculate `mid = (3 + 5) / 2 = 4`.
	- Recursively call `mergeSort(arr, 3, 4)` for the left half and `mergeSort(arr, 5, 5)` for the right half.
11. **Left Half (mergeSort(arr, 3, 4))**:
	- Since `beg < end`, we proceed to divide the array.
	- Calculate `mid = (3 + 4) / 2 = 3`.
	- Recursively call `mergeSort(arr, 3, 3)` for the left half and `mergeSort(arr, 4, 4)` for the right half.
12. **Left Half (mergeSort(arr, 3, 3))**:
	- Since `beg < end` is false, no action is taken.
13. **Right Half (mergeSort(arr, 4, 4))**:
	- Since `beg < end` is false, no action is taken.
14. **Merge (merge(arr, 3, 3, 4))**:
	- The previously sorted left half `[5]` and right half `[6]` are merged into sorted order: `[5, 6]`.

15. **Merge (merge(arr, 3, 4, 5))**:
	- The previously sorted left half `[5, 6]` and right half `[7]` are merged into sorted order: `[5, 6, 7]`.
16. **Merge (merge(arr, 0, 2, 5))**:
	- The previously sorted left half `[11, 12, 13]` and right half `[5, 6, 7]` are merged into the final sorted array: `[5, 6, 7, 11, 12, 13]`.
Thus, after all the merge operations, the array `[12, 11, 13, 5, 6, 7]` is sorted into `[5, 6, 7, 11, 12, 13]`.
##### Bottom-up:
 Even though we are thinking in terms of merging together two large subarrays, the fact is that most merges are merging together tiny subarrays. Another way to implement mergesort is to organize the merges so that we do all the merges of tiny arrays on one pass, then do a second pass to merge those arrays in pairs, and so forth, continuing until we do a merge that encompasses the whole array. This method requires even less code than the standard recursive implementation. We start by doing a pass of 1-by-1 merges (considering individual items as subarrays of size 1), then a pass of 2-by-2 merges (merge subarrays of size 2 to make subarrays of size 4), then 4-by-4 merges, and so forth.

![](https://algs4.cs.princeton.edu/22mergesort/images/mergesortBU.png)

```java
package Sort;

import java.util.Arrays;

public class MergeSortBottomUp<T extends Comparable <T>> {
    private boolean isLess(T a, T b){
        return a.compareTo(b)<0;
    }
    //To check is array is sorted
    private  boolean isSorted(T[] arr){
        boolean sorted=true;
        for(int i=1;i< arr.length;i++){
            if(isLess(arr[i],arr[i-1])){
                sorted=false;
                break;
            }
        }
        return sorted;
    }
    public void merge(T[] arr,int beg,int mid,int end){
        int n1=mid-beg+1;
        int n2=end-mid;
        T[] left= Arrays.copyOfRange(arr,beg,mid+1);
        T[] right=Arrays.copyOfRange(arr,mid+1,end+1);
        int i=0,j=0,k=beg;
        while(i<n1 && j<n2){
            if(isLess(right[j],left[i])){
                arr[k++]=right[j++];
            }else{
                arr[k++]=left[i++];
            }
        }
        while (i<n1){
            arr[k++]=left[i++];
        }
        while (j<n2){
            arr[k++]=right[j++];
        }
    }
    //Merging in bottom up manner
    //Starting with size as 1 then go 2,4 like that
    public void sort(T[] arr){
        if(arr==null || arr.length<=1){
            return;
        }
        int n=arr.length;
        for(int size=1;size<n;size*=2){
            for (int beg=0;beg<n-1;beg+=2*size){
                int mid=beg+size-1;
                int end=Math.min(beg+2*size-1,n-1);
                merge(arr,beg,mid,end);
            }
        }
    }
    public static void main(String[] args) {
        Integer[] arr = {12, 11, 13, 5, 6, 7};
        MergeSortBottomUp<Integer> ms1 = new MergeSortBottomUp<>();
        System.out.println(ms1.isSorted(arr));
        ms1.sort(arr);
        System.out.println(Arrays.toString(arr));
        System.out.println(ms1.isSorted(arr));
        MergeSortBottomUp<String> ms2 = new MergeSortBottomUp<>();
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        System.out.println(ms2.isSorted(stringArr));
        ms2.sort(stringArr);
        System.out.println(Arrays.toString(stringArr));
        System.out.println(ms2.isSorted(stringArr));
    }
}
```

Let's walk through the sorting process step by step using the provided array `{12, 11, 13, 5, 6, 7}`.

1. **Initialization**:
    - The array is `{12, 11, 13, 5, 6, 7}`.
    - We initialize `size` to 1 and enter the outer loop.
2. **First Iteration (size = 1)**:
    - The inner loop selects pairs of subarrays of size 1:
        - Subarrays: `{12}` and `{11}`, `{13}` and `{5}`, `{6}` and `{7}`.
    - Each pair is merged to form sorted subarrays.
    After this iteration, the array becomes `{11, 12, 5, 13, 6, 7}`.
3. **Second Iteration (size = 2)**:
    - The inner loop selects pairs of subarrays of size 2:
        - Subarrays: `{11, 12}` and `{5, 13}`, `{6, 7}`.
    - Each pair is merged to form sorted subarrays.
    After this iteration, the array becomes `{5, 11, 12, 13, 6, 7}`.
4. **Third Iteration (size = 4)**:
    - The inner loop selects pairs of subarrays of size 4:
        - Subarrays: `{5, 11, 12, 13}` and `{6, 7}`.
    - The last subarray `{6, 7}` is merged with an empty subarray.
    After this iteration, the array becomes `{5, 6, 7, 11, 12, 13}`.
5. **Fourth Iteration (size = 8)**:
    - Since the array length is less than 8, the loop terminates.
The final sorted array is `{5, 6, 7, 11, 12, 13}`.
#### Time Complexity
| Case | Time Complexity |
| ---- | ---- |
| **Best Case** | O(n log n) |
| **Average Case** | O(n log n) |
| **Worst Case** | O(n log n) 
### Quick Sort
Quicksort is the widely used sorting algorithm that makes **n log n** comparisons in average case for sorting an array of n elements. It is a faster and highly efficient sorting algorithm. This algorithm follows the divide and conquer approach.
**Divide:** In Divide, first pick a pivot element. After that, partition or rearrange the array into two sub-arrays such that each element in the left sub-array is less than or equal to the pivot element and each element in the right sub-array is larger than the pivot element.

**Conquer:** Recursively, sort two subarrays with Quicksort.

**Combine:** Combine the already sorted array.

**Choosing Pivot Element**
Picking a good pivot is necessary for the fast implementation of quicksort. However, it is typical to determine a good pivot. Some of the ways of choosing a pivot are as follows -
- Pivot can be random, i.e. select the random pivot from the given array.
- Pivot can either be the rightmost element of the leftmost element of the given array.
- Select median as the pivot element.

**Algorithm**
```
QUICKSORT (array A, start, end)     
{  
if (start < end)     
{  
p = partition(A, start, end)  
QUICKSORT (A, start, p - 1)    
QUICKSORT (A, p + 1, end)    
}   
}  
```
Partition:
```
PARTITION (array A, start, end)     
{  
pivot ? A[end]     
i ? start-1     
for j ? start to end -1 {  
do if (A[j] < pivot) {    
then i ? i + 1     
swap A[i] with A[j]   
}}   
swap A[i+1] with A[end]     
return i+1  
}  
```

#### Working
![](https://algs4.cs.princeton.edu/23quicksort/images/quicksort-overview.png)
The crux of the method is the partitioning process, which rearranges the array to make the following three conditions hold:

- The entry a[j] is in its final place in the array, for some j.
- No entry in a[lo] through a[j-1] is greater than a[j].
- No entry in a[j+1] through a[hi] is less than a[j].

We achieve a complete sort by partitioning, then recursively applying the method to the subarrays. It is a _randomized_ algorithm, because it randomly shuffles the array before sorting it because it reduces the chance of being worst case O(N^2).

#### Implementation
```java
package Sort;

import java.util.Arrays;
import java.util.Random;

public class QuickSort<T extends Comparable<T>> {
    public  boolean less(T a,T b){
        return a.compareTo(b)<0;
    }
    public  void swap(T[] arr,int i,int j){
        T temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;
    }
    public boolean isSorted(T[] arr){
        boolean sorted=true;
        for(int i=1;i<arr.length;i++){
            if(less(arr[i],arr[i-1])){
                sorted=false;
                break;
            }
        }
        return sorted;
    }
    public void shuffle(T[] arr){
        Random random=new Random();
        for(int i=0;i<arr.length;i++){
            int r= random.nextInt(0,i+1);
            swap(arr,i,r);
        }
    }

    public  int partition(T[] arr,int low,int high){
        T pivot=arr[low];//First element as pivot
        int i=low;
        int j=high+1;
        while (true) {
            // find item on lo to swap
            while (less(arr[++i], pivot)) {
                if (i == high) {
                    break;
                }
            }
            // find item on hi to swap
            while (less(pivot, arr[--j])) {
                if (j == low){
                    break;
                }
            }
            // check if pointers cross
            if (i >= j){
                break;
            }

            swap(arr, i, j);
        }
        // put partitioning item pivot at a[j]
        swap(arr, low, j);
        // now, a[lo .. j-1] <= a[j] <= a[j+1 .. hi]
        return j;
    }
    public void sort(T[] arr){
        shuffle(arr);//Shuffle in order to avoid worst case
        sort(arr,0,arr.length-1);
        System.out.println(isSorted(arr));
    }
    public void sort(T[] arr,int low,int high){
        if(high<=low){
            return;
        }
        int pivot=partition(arr,low,high);
        sort(arr,low,pivot-1);
        sort(arr,pivot+1,high);
    }
    public static void main(String[] args) {
        QuickSort<Integer> qs1=new QuickSort<>();
        Integer[] arr={12, 11, 13, 5, 6, 7};
        qs1.sort(arr);
        System.out.println(Arrays.toString(arr));
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        QuickSort<String> qs2=new QuickSort<>();
        qs2.sort(stringArr);
        System.out.println(Arrays.toString(stringArr));
    }
}
```
Let's walk through the Quick Sort algorithm step by step with the input array `[12, 11, 13, 5, 6, 7]`.

1. **Initial Array:** `[12, 11, 13, 5, 6, 7]`
2. **Partitioning:**
    - Choose the first element `12` as the pivot.
    - Rearrange the array such that all elements less than or equal to the pivot are on the left side, and all elements greater than the pivot are on the right side.
    - After the first partitioning, the array becomes `[6, 11, 7, 5, 12, 13]`.
    - The pivot (`12`) is now at index `4`.
3. **Recursive Calls:**
    - Recursively apply Quick Sort to the left partition `[6, 11, 7, 5]`.
    - Recursively apply Quick Sort to the right partition `[13]`.
4. **Partitioning the Left Partition `[6, 11, 7, 5]`:**
    - Choose the first element `6` as the pivot.
    - Rearrange the array such that all elements less than or equal to the pivot are on the left side, and all elements greater than the pivot are on the right side.
    - After partitioning, the array becomes `[5, 6, 7, 11]`.
    - The pivot (`6`) is now at index `1`.
5. **Recursive Calls (Left Partition `[5, 6, 7, 11]`):**
    - No more recursive calls because the left partition has only one element (`5`).
6. **Recursive Calls (Right Partition `[13]`):**
    - No more recursive calls because the right partition has only one element (`13`).
7. **Merging:**
    - As both the left and right partitions are sorted, and there are no further partitions to sort, we simply merge them with the pivot to get the final sorted array: `[5, 6, 7, 11, 12, 13]`.
8. **Final Sorted Array:** `[5, 6, 7, 11, 12, 13]`.

This is how the Quick Sort algorithm sorts the array `[12, 11, 13, 5, 6, 7]` in ascending order.

**In Detail explanation of First Partition**

1. **Choosing the Pivot:**
    - In this implementation, the pivot is chosen as the first element of the array. So, `12` is chosen as the pivot.
2. **Partitioning Process:**
    - Initialize two pointers, `i` and `j`, pointing to the first and last elements of the array respectively.
    - Increment `i` until we find an element greater than or equal to the pivot.
    - Decrement `j` until we find an element less than or equal to the pivot.
    - Swap the elements at positions `i` and `j` if `i` is less than `j`.
    - Repeat the above steps until `i` is greater than or equal to `j`.
3. **Detailed Partitioning Steps:**
    - Start with the array `[12, 11, 13, 5, 6, 7]`.
    - Pivot: `12`.
    - `i` points to `11`, and `j` points to `7`.
	- Increment `i` until finding an element greater than or equal to the pivot (`13`).
    - Decrement `j` until finding an element less than or equal to the pivot (`7`).
    - Swap `13` and `7`.
    - Increment `i` until finding an element greater than or equal to the pivot (`5`).
    - Decrement `j` until finding an element less than or equal to the pivot (`6`).
    - Swap `5` and `6`.
    - `i` and `j` crossed, so stop the partitioning process.
    - Swap the pivot (`12`) with the element at index `j` (`6`).
4. **Resulting Partition:**
    - After partitioning, the pivot (`12`) is placed at its correct position such that all elements to its left are less than or equal to it, and all elements to its right are greater than it.
    - The partitioned array is `[6, 11, 7, 5, 12, 13]`.
    - The index `j` (pointing to `12`) indicates the correct position of the pivot in the sorted array.
This completes the first partitioning step of the Quick Sort algorithm for the given array.
#### Time Complexity
| Case | Time Complexity |
| ---- | ---- |
| **Best Case** | O(n log n) |
| **Average Case** | O(n log n) |
| **Worst Case** | O(n^2) |
Worst case can be avoided by shuffling the array.
### Dijkstra's Three Pointer
Dijkstra's 3-way partitioning is a technique used in computer science primarily in the context of sorting algorithms, particularly quicksort. It's an enhancement to the standard partitioning step in quicksort that handles cases where there are many duplicate elements efficiently.
**Algorithm**
```
procedure dijkstraThreePointer(nums: array of integers)
    low := 0
    mid := 0
    high := length(nums) - 1

    while mid <= high
        if nums[mid] == 0 then
            swap(nums, low, mid)
            low := low + 1
            mid := mid + 1
        else if nums[mid] == 1 then
            mid := mid + 1
        else // nums[mid] == 2
            swap(nums, mid, high)
            high := high - 1

procedure swap(nums: array of integers, i: integer, j: integer)
    temp := nums[i]
    nums[i] := nums[j]
    nums[j] := temp
```
#### Working
In traditional quicksort, you choose a pivot element and partition the array into two parts: elements less than the pivot and elements greater than the pivot. However, if the array contains many duplicate elements equal to the pivot, this can lead to suboptimal performance.

Dijkstra's 3-way partitioning divides the array into three parts instead of two:

1. Elements less than the pivot.
2. Elements equal to the pivot.
3. Elements greater than the pivot.

Here's a basic outline of the algorithm:
1. Choose a pivot element from the array.
2. Initialize three pointers: `low`, `mid`, and `high`.
    - `low` points to the beginning of the array.
    - `mid` points to the current position being processed.
    - `high` points to the end of the array.
3. Iterate through the array, moving elements to their appropriate positions:
    - If the element at position `mid` is less than the pivot, swap it with the element at position `low` and increment both `low` and `mid`.
    - If the element at position `mid` is equal to the pivot, leave it in place and increment `mid`.
    - If the element at position `mid` is greater than the pivot, swap it with the element at position `high` and decrement `high`.
4. Continue this process until `mid` crosses `high`.
5. After partitioning, you'll have three regions:
    - Elements before `low` are less than the pivot.
    - Elements between `low` and `mid` are equal to the pivot.
    - Elements after `high` are greater than the pivot.
6. Recursively apply the partitioning process to the subarrays before and after the equal elements region.

This technique helps in scenarios where there are many duplicate elements in the array, as it reduces unnecessary swaps and ensures that equal elements stay grouped together, leading to more efficient sorting.

#### Implementation
```java
package Sort;

import java.util.Arrays;

public class DijkstrasQuickSort<T extends Comparable<T>> {
    private void swap(T[] arr, int i, int j) {
        T temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public void sort(T[] arr, int low, int high) {
        if (high <= low) {
            return;
        }
        int lt = low, gt = high;//lt pivot pointer
        T v = arr[low];
        int i = low;
        while (i <= gt) {
            int cmp = arr[i].compareTo(v);//Compare pivot and ith variable
            if (cmp < 0) {
                swap(arr, lt++, i++);//If less swap i with pivot then increment position
            } else if (cmp > 0) {
                swap(arr, i, gt--);//If greater swap i with gt decrement gt
            } else {
                i++;//Equal means increment i
            }
        }
        sort(arr, low, lt - 1);
        sort(arr, gt + 1, high);
    }

    public static void main(String[] args) {
        DijkstrasQuickSort<Integer> dqs1 = new DijkstrasQuickSort<>();
        Integer[] arr = {12, 11, 13, 5, 6, 7};
        dqs1.sort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
        String[] stringArr = {"banana", "apple", "orange", "grape", "kiwi"};
        DijkstrasQuickSort<String> dqs2 = new DijkstrasQuickSort<>();
        dqs2.sort(stringArr, 0, stringArr.length - 1); // Corrected here
        System.out.println(Arrays.toString(stringArr));
    }
}
```

Let's walk through the sorting process of the array {12, 11, 12, 13, 5, 6, 7} using the provided code:

1. **Initialization**:
    - The `sort` method is called with the array {12, 11, 12, 13, 5, 6, 7}, and the range `[0, 6]`.
2. **Partitioning**:
    - The pivot `v` is set to the first element of the array, which is 12.
    - Three pointers are initialized: `lt` at `low`, `gt` at `high`, and `i` at `low`.
    - The array is iterated from left to right:
        - At `i = 0`, `arr[i] = 12`, which is equal to the pivot. `i` is incremented.
        - At `i = 1`, `arr[i] = 11`, which is less than the pivot. So, `11` is swapped with `12` at position `lt`, and both `lt` and `i` are incremented. The array becomes {11, 12, 12, 13, 5, 6, 7}.
        - At `i = 2`, `arr[i] = 12`, which is equal to the pivot. `i` is incremented.
        - At `i = 3`, `arr[i] = 13`, which is greater than the pivot. So, `13` is swapped with `12` at position `gt`, and `gt` is decremented. The array becomes {11, 12, 12, 7, 5, 6, 13}.
        - At `i = 3`, `arr[i] = 7`, which is less than the pivot. So, `7` is swapped with `11` at position `lt`, and both `lt` and `i` are incremented. The array becomes {7, 12, 12, 11, 5, 6, 13}.
        - At `i = 4`, `arr[i] = 5`, which is less than the pivot. So, `5` is swapped with `7` at position `lt`, and both `lt` and `i` are incremented. The array becomes {5, 12, 12, 11, 7, 6, 13}.
        - At `i = 5`, `arr[i] = 6`, which is less than the pivot. So, `6` is swapped with `12` at position `lt`, and both `lt` and `i` are incremented. The array becomes {5, 6, 12, 11, 7, 12, 13}.
        - At `i = 6`, `arr[i] = 13`, which is greater than the pivot. So, `13` is swapped with `12` at position `gt`, and `gt` is decremented. The array remains {5, 6, 12, 11, 7, 12, 13}.
    - At this point, the array is partitioned into three segments: {5, 6, 7, 11}, {12, 12}, and {13}.
3. **Recursion**:
    - Recursively, the `sort` method is called for the subarrays `[0, 3]` and `[5, 6]`.
4. **Sorting Complete**:
    - After sorting completes, the array becomes {5, 6, 7, 11, 12, 12, 13}.
### Stability
Stability refers to a characteristic where the relative order of elements with equal keys remains unchanged after the sorting process.For example, suppose you have an array of objects with key-value pairs, and you want to sort them based on the keys. If two objects have the same key, a stable sorting algorithm ensures that their relative order in the sorted array is the same as their original order in the unsorted array.
Let's analyze each sorting algorithm in terms of stability:

1. **Merge Sort**: Merge sort is a stable sorting algorithm. During the merging step, when two elements are equal, merge sort always selects the element from the left subarray first. This ensures that the relative order of equal elements is preserved.
2. **Insertion Sort**: Insertion sort is generally considered stable. When elements are inserted into their correct positions, they are placed relative to other elements with equal keys in the same order as they appeared in the original array. Therefore, insertion sort typically preserves the original order of equal elements.
3. **Selection Sort**: Selection sort is not stable. During each iteration, the algorithm selects the smallest (or largest) element and swaps it with the element at the current position. This swapping may change the relative order of equal elements.
4. **Shell Sort**: Shell sort is not stable. It involves repeatedly sorting elements that are distant from each other. This process may cause elements with equal keys to be reordered.
5. **Quick Sort**: Quick sort is not inherently stable. Depending on the implementation, it may or may not preserve the relative order of equal elements. In typical implementations, quick sort involves partitioning the array around a pivot element, and the partitioning process may change the order of equal elements.
In summary:
- Merge sort and insertion sort are generally stable.
- Selection sort, shell sort, and quick sort are typically not stable, although specific implementations may be modified to maintain stability.

### Comparator & Comparable
In Java, both `Comparator` and `Comparable` interfaces are used for sorting objects, but they differ in their implementation and usage.

1. **Comparable Interface**:
    - The `Comparable` interface is used to define the natural ordering of objects of a class.
    - To make a class objects comparable, it must implement the `Comparable` interface and override the `compareTo()` method.
    - The `compareTo()` method returns a negative integer, zero, or a positive integer if the current object is less than, equal to, or greater than the specified object, respectively.
    - For example, if you have a class `Person` and you want to sort `Person` objects based on their age, you would implement `Comparable` in the `Person` class and override `compareTo()` to compare ages.
2. **Comparator Interface**:
    - The `Comparator` interface is used to define a custom way of sorting objects.
    - It's useful when you want to sort objects based on different criteria than their natural ordering, or when you don't have control over the class whose objects you want to sort.
    - To use a `Comparator`, you create a separate class that implements the `Comparator` interface and overrides the `compare()` method.
    - The `compare()` method takes two objects as arguments and returns a negative integer, zero, or a positive integer as the first argument is less than, equal to, or greater than the second.
    - For example, you can have a `PersonComparator` class that implements `Comparator<Person>` and sorts `Person` objects based on their names.

In summary, `Comparable` is for defining the natural ordering of objects within a class, while `Comparator` is for defining multiple custom ways of sorting objects or sorting objects of classes that you don't have control over.

#### Implementation
**Insertion**
```java
package Sort.Comparator;

import java.util.Comparator;

public class Insertion {
    public static void sort(Object[] a, Comparator comparator)
    {
        int N = a.length;
        for (int i = 0; i < N; i++)
            for (int j = i; j > 0 && less(comparator, a[j], a[j-1]); j--)
                exch(a, j, j-1);
    }
    //Custom Defined Descending order
    static class IntegerDesceComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer a, Integer b) {
            return b.compareTo(a);
        }
    }
    //Custom Defined Ascending order
    static class IntegerAsceComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer a, Integer b) {
            return a.compareTo(b);
        }
    }
    private static boolean less(Comparator c, Object v, Object w)
    { return c.compare(v, w) < 0; }
    private static void exch(Object[] a, int i, int j)
    { Object swap = a[i]; a[i] = a[j]; a[j] = swap; }

    public static void main(String[] args) {
        Integer[] numbers={10,2,14,56,3,1};
        //Sort the array using a custom comparator descending
        sort(numbers, new IntegerDesceComparator());

        //Print the sorted array
        for (Integer number : numbers) {
            System.out.print(number + " ");
        }
        System.out.println();
        //Sort the array using a custom comparator ascending
        sort(numbers, new IntegerAsceComparator());

        //Print the sorted array
        for (Integer number : numbers) {
            System.out.print(number + " ");
        }
    }
}
```

**Student.java**
```java
package Sort.Comparator;

import java.util.Comparator;

public class Student {
    public final static  Comparator<Student> By_name=new byName();
    public final static Comparator<Student> By_section=new bySection();
    private final String name;
    private final int section;
    public Student(String name,int section){
        this.name=name;
        this.section=section;
    }
    public String getName() {
        return name;
    }

    public int getSection() {
        return section;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", section=" + section +
                '}';
    }
    private static class byName implements Comparator<Student>{
        public int compare(Student a,Student b){
            return a.name.compareTo(b.name);
        }
    }
    private static class bySection implements Comparator<Student>{
        public int compare(Student a,Student b){
            return a.section-b.section;
        }
    }
}
```

**System Sort**
```java
package Sort.Comparator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SystemSort {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Alice", 1));
        students.add(new Student("Bob", 2));
        students.add(new Student("Charlie", 1));

        // Sort students by name
        Collections.sort(students, Student.By_name);
        System.out.println("Sorted by name:");
        for (Student student : students) {
            System.out.println(student);
        }

        // Sort students by section
        Collections.sort(students, Student.By_section);
        System.out.println("\nSorted by section:");
        for (Student student : students) {
            System.out.println(student);
        }
    }
}
```

**Merge Sort Implementation**
```java
package Sort.Comparator;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

public class MergeSort<T> {
    /*Comparator<T>: This represents a comparator that can compare objects of type T.
    <? super T>: This is a bounded wildcard that specifies that the comparator can compare objects of type T or any supertype of T.
    It allows for greater flexibility in using comparators.
     */
    public void sort(List<T> list, Comparator<? super T> c) {
        if (list == null || list.size() <= 1) {
            return;
        }
        mergerSort(list, 0, list.size() - 1, c);
    }

    private static <T> boolean less(Comparator<? super T> c, T a, T b) {
        return c.compare(a, b) < 0;
    }

    private void merge(List<T> list, int beg, int mid, int end, Comparator<? super T> c) {
        int n1 = mid - beg + 1;
        int n2 = end - mid;

        List<T> left = new ArrayList<>(list.subList(beg, mid + 1));
        List<T> right = new ArrayList<>(list.subList(mid + 1, end + 1));

        int i = 0, j = 0, k = beg;
        while (i < n1 && j < n2) {
            if (less(c, right.get(j), left.get(i))) {
                list.set(k++, right.get(j++));
            } else {
                list.set(k++, left.get(i++));
            }
        }
        while (i < n1) {
            list.set(k++, left.get(i++));
        }
        while (j < n2) {
            list.set(k++, right.get(j++));
        }
    }

    private void mergerSort(List<T> list, int beg, int end, Comparator<? super T> c) {
        if (beg < end) {
            int mid = (beg + end) / 2;
            mergerSort(list, beg, mid, c);
            mergerSort(list, mid + 1, end, c);
            merge(list, beg, mid, end, c);
        }
    }

    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Alice", 1));
        students.add(new Student("Bob", 2));
        students.add(new Student("Charlie", 1));

        MergeSort<Student> mergeSort = new MergeSort<>();

        // Sort students by name
        mergeSort.sort(students, Student.By_name);
        System.out.println("Sorted by name:");
        for (Student student : students) {
            System.out.println(student);
        }

        // Sort students by section
        mergeSort.sort(students, Student.By_section);
        System.out.println("\nSorted by section:");
        for (Student student : students) {
            System.out.println(student);
        }
    }
}
```

### System Sort
Arrays.sort(). 
- Has different method for each primitive type. 
- Has a method for data types that implement Comparable. 
- Has a method that uses a Comparator. 
- Uses tuned quicksort for primitive types; tuned mergesort for objects.

```java
package Sort;

import java.util.Arrays;

public class SystemSort {
    public static void main(String[] args) {
        int[] arr={10,21,45,134,5,11,1};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));
    }
}

```

```java
package Sort.Comparator;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class SystemSort {
    public static void main(String[] args) {
        List<Student> students = new ArrayList<>();
        students.add(new Student("Alice", 1));
        students.add(new Student("Bob", 2));
        students.add(new Student("Charlie", 1));

        // Sort students by name
        Collections.sort(students, Student.By_name);
        System.out.println("Sorted by name:");
        for (Student student : students) {
            System.out.println(student);
        }

        // Sort students by section
        Collections.sort(students, Student.By_section);
        System.out.println("\nSorted by section:");
        for (Student student : students) {
            System.out.println(student);
        }
    }
}
```

### Sorting Applications
Sorting algorithms are crucial in various applications across different domains. Here's a brief overview of sorting applications:

1. **Database Systems**: Sorting is used in database systems to order records based on specific criteria, facilitating efficient searching and retrieval of data.
2. **Web Search Engines**: Sorting algorithms help rank search results based on relevance, ensuring that the most relevant results are presented to users first.
3. **Operating Systems**: Sorting is used in operating systems for tasks such as process scheduling, memory allocation, and file system organization.
4. **Graph Algorithms**: Sorting plays a role in various graph algorithms, such as finding minimum spanning trees and shortest paths.
5. **Numerical Analysis**: Sorting is used in numerical analysis for tasks like interpolation, root finding, and curve fitting.
6. **Computer Graphics**: Sorting is used for rendering objects based on their depth and sorting pixels for rendering transparency effects.
7. **Compression Algorithms**: Sorting can be used to reorder data for better compression ratios in compression algorithms.
8. **Networking**: Sorting is used in networking protocols for routing packets and prioritizing packets based on quality of service parameters.
9. **Genetic Algorithms**: Sorting is used in genetic algorithms for ranking solutions based on fitness values and sorting populations based on genetic diversity.
10. **Data Analysis and Visualization**: Sorting is used to organize and present data in data analysis and visualization tasks, making patterns and trends more apparent.
### Sorting Summary
![[Pasted image 20240215143350.png]]