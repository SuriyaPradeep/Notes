#oop #objects #class 
### What is OOP?
As the name suggests, [Object-Oriented Programming](https://www.geeksforgeeks.org/object-oriented-programming-oops-concept-in-java/) or OOPs refers to languages that use objects in programming, they use objects as a primary source to implement what is to happen in the code.

### Access Modifier
#access-modifier
Defines the *access type* of the method i.e. from where it can be accessed in your application. In Java, there are 4 types of access specifiers: 

- *public*: Accessible in all classes in your application.
- *protected:* Accessible within the package in which it is defined and in its subclass(es) (including subclasses declared outside the package).
- *private:* Accessible only within the class in which it is defined.
- *default (declared/defined without using any modifier):* Accessible within the same class and package within which its class is defined.

### Concepts of OPP
![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20190717114649/Object-Oriented-Programming-Concepts.jpg)

#### Class and Object
A [class](https://www.geeksforgeeks.org/classes-objects-java/) is a user-defined blueprint or prototype from which objects are created. It represents the set of properties or methods that are common to all objects of one type. Using classes, you can create multiple objects with the same behavior instead of writing their code multiple times.

An **Object** refers to an independent entity that contains both data (instance variables) and behavior (methods).
*An object* is a basic unit of Object-Oriented Programming that represents real-life entities.
**The state of an object** is the value of its internal variables at any given point in time.

The `this` keyword refers to the current object in a method or constructor.
The most common use of the `this` keyword is to eliminate the confusion between class attributes and parameters with the same name (because a class attribute is shadowed by a method or constructor parameter).

*toString():* If you print any object, Java compiler internally invokes the toString() method on the object. So overriding the toString() method, returns the desired output, it can be the state of an object etc. depending on your implementation.

*Example:* Creating a simple banking application using class and objects

**Banking.java**
```java
package classAndObjects;  
  
public class Banking {  
//Private makes it only accessible to the class  
private double balance;  
//final will not let the value change  
private final String name;  
  
//Creating a constructor  
public Banking(String name, double startingBalance) {  
this.balance = startingBalance;  
this.name = name;  
//Here this means current object  
}  
public String deposit(double amt){  
if(amt>0){  
this.balance+=amt;  
return amt+" has been deposited.";  
} else{  
return amt+" cannot be deposited.";  
}  
}  
public String withdrawal(double amt){  
if(amt>this.balance){  
return "Insufficient Balance\nWithdrawal Cancelled";  
} else if(amt<=0){  
return amt+" cannot be withdrawn.";  
} else{  
this.balance=this.balance-amt;  
return amt+" has been withdrawn\nCurrent Balance: "+this.balance;  
}  
}  
//If you want to represent any object as a string, toString() method comes into existence.  
//If you print any object, Java compiler internally invokes the toString() method on the object.  
// So overriding the toString() method, returns the desired output, it can be the state of an object etc.  
@Override  
public String toString(){  
return this.name+":"+this.balance;  
}  
}
```


**Main.java**
```java
package classAndObjects;  
  
public class Main {  
public static void main(String[] args) {  
//Creating Object  
Banking mattAcc=new Banking("Matt",100);  
System.out.println(mattAcc.withdrawal(25));  
System.out.println(mattAcc.withdrawal(100));  
System.out.println(mattAcc.deposit(50));  
System.out.println(mattAcc);  
}  
}
```

**final**: #final
The word `final` used in the definition of object variables catches attention. The result of this word is that the values of these object variables cannot be modified after they have been set in the constructor.

#### Abstractions
#abstraction
Data Abstraction is the property by virtue of which only the essential details are displayed to the user. The trivial or non-essential units are not displayed to the user.
Consider a real-life example of a man driving a car. The man only knows that pressing the accelerators will increase the car speed or applying brakes will stop the car, but he does not know how on pressing the accelerator, the speed is actually increasing. He does not know about the inner mechanism of the car or the implementation of the accelerators, brakes etc. in the car. This is what abstraction is.

The abstract method contains only method declaration but not implementation.
Demonstration of Abstract class
```java
//abstract class 
abstract class GFG{ 
  //abstract methods declaration 
  abstract void add(); 
  abstract void mul(); 
  abstract void div(); 
} 
```

#### Encapsulation
#encapsulation
It is defined as the wrapping up of data under a single unit. It is the mechanism that binds together the code and the data it manipulates. Another way to think about encapsulation is that it is a protective shield that prevents the data from being accessed by the code outside this shield. 

- Technically, in encapsulation, the variables or the data in a class is hidden from any other class and can be accessed only through any member function of the class in which they are declared.
- In encapsulation, the data in a class is hidden from other classes, which is similar to what ****data-hiding**** does. So, the terms “encapsulation” and “data-hiding” are used interchangeably.
- Encapsulation can be achieved by declaring all the variables in a class as private and writing public methods in the class to set and get the values of the variables.

Demonstration of Encapsulation:
```java
//Encapsulation using private modifier 
//Employee class contains private data called employee id and employee name 
class Employee { 
	private int empid; 
	private String ename; 
} 
```


#### Inheritance
#inheritance
Inheritance is an important pillar of OOP (Object Oriented Programming). It is the mechanism in Java by which one class is allowed to inherit the features (fields and methods) of another class. We are achieving inheritance by using *extends* keyword.

Let us discuss some frequently used important terminologies:

- Superclass: The class whose features are inherited is known as superclass (also known as base or parent class).
- Subclass: The class that inherits the other class is known as subclass (also known as derived or extended or child class). The subclass can add its own fields and methods in addition to the superclass fields and methods.
- Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is already a class that includes some of the code that we want, we can derive our new class from the existing class.

Demonstration of Inheritance :
```java
//base class or parent class or super class 
class A{ 
//parent class methods 
void method1(){} 
void method2(){} 
} 
//derived class or child class or base class 
class B extends A{ //Inherits parent class methods 
//child class methods 
void method3(){} 
void method4(){} 
}
```

#### Polymorphism
#polymorphism
It refers to the ability of object-oriented programming languages to differentiate between entities with the same name efficiently. This is done by Java with the help of the signature and declaration of these entities. The ability to appear in many forms is called *polymorphism*.

```java
sleep(1000) //millis 

sleep(1000,2000) //millis,nanos

```

Here two method of same name is called but it can be differentiated using number and type of the parameter.

### Overloading
#overloading
In java, Overloading allows different methods to have the same name, but different signatures where the signature can differ by the number of input parameters or type of input parameters, or a mixture of both.

**Types of Overloading**
- Constructor Overloading
- Method Overloading


*Example:*
```java
// Java program to demonstrate working of method 
// overloading in Java 

public class Sum { 
	// Overloaded sum(). This sum takes two int parameters 
	public int sum(int x, int y) { return (x + y); } 

	// Overloaded sum(). This sum takes three int parameters 
	public int sum(int x, int y, int z) 
	{ 
		return (x + y + z); 
	} 

	// Overloaded sum(). This sum takes two double 
	// parameters 
	public double sum(double x, double y) 
	{ 
		return (x + y); 
	} 

	// Driver code 
	public static void main(String args[]) 
	{ 
		Sum s = new Sum(); 
		System.out.println(s.sum(10, 20)); 
		System.out.println(s.sum(10, 20, 30)); 
		System.out.println(s.sum(10.5, 20.5)); 
	} 
}

```

**Different Ways of Overloading in Java**
- Changing the Number of Parameters.
- Changing Data Types of the Arguments.
- Changing the Order of the Parameters.

The technique of having two (or more) constructors in a class is known as _constructor overloading_. A class can have multiple constructors that differ in the number and/or type of their parameters. It's not, however, possible to have two constructors with the exact same parameters.

A constructor can be called from another constructor using the `this` keyword.
Lets Explain this with and example.
```java
public Person(String name) {
    this(name, 0);
    //here the code of the second constructor is run, and the age is set to 0
}

public Person(String name, int age) {
    this.name = name;
    this.age = age;
    this.weight = 0;
    this.height = 0;
}
```
Here Two constructors are defined. First constructors calls second constructors so there is no repetition of code.
**Implementation**
*Counter.java*
```java
package OverloadCounter;

public class Counter {
    private int count;
    //Constructor Overloading
    //Constructor 1
    //Overloading with two different parameters
    public Counter(int startValue){
        this.count=startValue;
    }
    //Constructor 2
    public Counter(){
        this(0);
        //Constructor 2 calling 1
    }
    public int value(){
        return this.count;
    }
    //Method Overloading

    //Overloading with two different parameters
    public void increase(){
        this.count++;
    }
    public void increase(int increaseBy){
        //Does not change for negative or zero
        if(increaseBy>0)
            this.count+=increaseBy;
    }
    public void decrease(){
        this.count--;
    }
    public void decrease(int decreaseBy){
        if(decreaseBy>0)
            this.count-=decreaseBy;
    }
}

```

*Main.java*
```java
package OverloadCounter;

public class Main {
    public static void main(String[] args) {
        Counter count1=new Counter();
        Counter count2=new Counter(1);
        System.out.println("Counter 1:"+count1.value());
        System.out.println("Counter 2:"+count2.value());
        count1.increase();
        count2.increase(4);
        count1.decrease(5);
        count2.decrease();
        System.out.println("Counter 1:"+count1.value());
        System.out.println("Counter 2:"+count2.value());
    }
}

```


----