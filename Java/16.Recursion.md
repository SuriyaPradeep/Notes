#recursion
In Java, Recursion is a process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called a recursive function. Using a recursive algorithm, certain problems can be solved quite easily. A few Java recursion examples are [Towers of Hanoi (TOH)](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/), [Inorder/Preorder/Postorder Tree Traversals](https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/), [DFS of Graph](https://www.geeksforgeeks.org/depth-first-traversal-for-a-graph/), etc.

### Base Condition in Recursion

In the recursive program, the solution to the base case is provided and the solution to the bigger problem is expressed in terms of smaller problems.

```java
int fact(int n)
{
    if (n < = 1) // base case
        return 1;
    else    
        return n*fact(n-1);    
}
```

In the above example, the base case for n < = 1 is defined and the larger value of a number can be solved by converting it to a smaller one till the base case is reached. 

### Working of Recursion

The idea is to represent a problem in terms of one or more smaller sub-problems and add base conditions that stop the recursion. For example, we compute factorial n if we know the factorial of (n-1). The base case for factorial would be n = 0. We return 1 when n = 0.

![Java Recursion](https://media.geeksforgeeks.org/wp-content/uploads/20230417232220/Recursion-in-Java-1-768.webp)

### **How is memory allocated to different function calls in recursion?**

When any function is called from main(), the memory is allocated to it on the stack. A recursive function calls itself, the memory for the called function is allocated on top of memory allocated to the calling function and a different copy of local variables is created for each function call. When the base case is reached, the function returns its value to the function by whom it is called and memory is de-allocated and the process continues. 

Let us take the example of recursion by taking a simple function. 
```java
// A Java program to demonstrate
// working of recursion

class GFG {
	static void printFun(int test)
	{
		if (test < 1)
			return;

		else {
			System.out.printf("%d ", test);

			// Statement 2
			printFun(test - 1);

			System.out.printf("%d ", test);
			return;
		}
	}

	public static void main(String[] args)
	{
		int test = 3;
		printFun(test);
	}
}

```
**Output**

```
3 2 1 1 2 3 
```

#### Explanation of the above Program

When **printFun(3)** is called from main(), memory is allocated to **printFun(3),** a local variable test is initialized to 3, and statements 1 to 4 are pushed on the stack as shown below diagram. It first prints ‘3’.

In statement 2, **printFun(2)** is called and memory is allocated to **printFun(2),** a local variable test is initialized to 2, and statements 1 to 4 are pushed in the stack. Similarly, **printFun(2)** calls **printFun(1)** and **printFun(1)** calls **printFun(0)**. **printFun(0)** goes to if statement and it return to **printFun(1)**.

The remaining statements of **printFun(1)** are executed and it returns to **printFun(2)** and so on. In the output, values from 3 to 1 are printed and then 1 to 3 are printed. 

**The memory stack is shown in the below diagram**:

![memory stack representation of recursion in java](https://media.geeksforgeeks.org/wp-content/uploads/20230417232252/Recursion-in-Java-2-768.webp)

Memory Stack Representation of Java Recursive Program
### Problems
Some Problems to understand recursion better.

**Factorial**
#factorial

```java
package Recursion;
import java.util.*;
public class Factorial {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        System.out.println("Enter a number to find factorial:");
        int num=Integer.valueOf(scanner.nextLine());
        System.out.println("Factorial of number "+num+" is "+fact(5));
    }
    public static int fact(int num){
        if(num==1){
            return 1;
        }
        return num*fact(num-1);
    }
}
```

Now, let's visualize the recursive calls using a stack diagram for `factorial(5)`:

1. Initial call: `factorial(5)
    - Since `n` is not 0 or 1, it goes to the else block.
    - It calls `factorial(4)`.
2. `factorial(4)`
    - Similarly, it's not 0 or 1, so it calls `factorial(3)`.
3. `factorial(3)`
    - Continues the pattern and calls `factorial(2)`.
4. `factorial(2)`
    - Calls `factorial(1)`.
5. `factorial(1)`
    - Returns 1, as it's the base case.

Now, the stack starts to unwind:

6. `factorial(2)` receives the result from `factorial(1)` and returns `2 * 1 = 2`.    
7. `factorial(3)` receives the result from `factorial(2)` and returns `3 * 2 = 6`.
8. `factorial(4)` receives the result from `factorial(3)` and returns `4 * 6 = 24`.    
9. `factorial(5)` receives the result from `factorial(4)` and returns `5 * 24 = 120`.


Finally, the main method prints the result: "Factorial of 5 is: 120".


**Fibonacci Series**
#fibonacci
```java
package Recursion;
import java.util.*;
public class Fibonacci_Series {
    public static void main(String[] args) {
        Scanner scanner=new Scanner(System.in);
        System.out.println("Enter a number to find Fibonacci Series:");
        int num=Integer.valueOf(scanner.nextLine());
        System.out.println("Fibonacci Series of number "+num+" is "+fibonacci(num));
    }
    public static int fibonacci(int num){
        if(num==1|| num==0){
            return num;
        }
        return fibonacci(num-1)+fibonacci(num-2);
    }
}
```

Now, let's visualize the recursive calls using a stack diagram for `fibonacci(5)`:

1. Initial call: `fibonacci(5)`
    
    - Since `n` is greater than 1, it goes to the else block.
    - Calls `fibonacci(4)` and `fibonacci(3)`.
2. `fibonacci(4)`
    - Calls `fibonacci(3)` and `fibonacci(2)`.
3. `fibonacci(3)`
    - Calls `fibonacci(2)` and `fibonacci(1)`.
4. `fibonacci(2)`
    - Calls `fibonacci(1)` and `fibonacci(0)`.
5. `fibonacci(1)` and `fibonacci(0)`
    - Return 1 and 0, respectively, as they are the base cases.

Now, the stack starts to unwind:

6. `fibonacci(2)` receives results from `fibonacci(1)` and `fibonacci(0)`, returns `1 + 0 = 1`.
7. `fibonacci(3)` receives results from `fibonacci(2)` and `fibonacci(1)`, returns `1 + 1 = 2`.
8. `fibonacci(4)` receives results from `fibonacci(3)` and `fibonacci(2)`, returns `2 + 1 = 3`.
9. `fibonacci(5)` receives results from `fibonacci(4)` and `fibonacci(3)`, returns `3 + 2 = 5`.

Finally, the main method prints the result: "Fibonacci(5): 5".

### **Advantages of Recursive Programming**

The advantages of recursive programs are as follows:

- Recursion provides a clean and simple way to write code.
- Some problems are inherently recursive like tree traversals, [Tower of Hanoi](https://www.geeksforgeeks.org/c-program-for-tower-of-hanoi/), etc. For such problems, it is preferred to write recursive code.

### **Disadvantages of Recursive Programming**

The disadvantages of recursive programs is as follows:

- The recursive program has greater space requirements than the iterative program as all functions will remain in the stack until the base case is reached.
- It also has greater time requirements because of function calls and returns overhead.

----