#graph #dijkstras
26-07-2024
### Question
There are `n` cities numbered from `0` to `n-1`. Given the array `edges` where `edges[i] = [fromi, toi, weighti]` represents a bidirectional and weighted edge between cities `fromi` and `toi`, and given the integer `distanceThreshold`.

Return the city with the smallest number of cities that are reachable through some path and whose distance is **at most** `distanceThreshold`, If there are multiple such cities, return the city with the greatest number.

Notice that the distance of a path connecting cities _**i**_ and _**j**_ is equal to the sum of the edges' weights along that path.

**Example 1:**

![](https://assets.leetcode.com/uploads/2020/01/16/find_the_city_01.png)

**Input:** n = 4, edges = [[0,1,3],[1,2,1],[1,3,4],[2,3,1]], distanceThreshold = 4
**Output:** 3
**Explanation:** The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 4 for each city are:
City 0 -> [City 1, City 2] 
City 1 -> [City 0, City 2, City 3] 
City 2 -> [City 0, City 1, City 3] 
City 3 -> [City 1, City 2] 
Cities 0 and 3 have 2 neighboring cities at a distanceThreshold = 4, but we have to return city 3 since it has the greatest number.

**Example 2:**

![](https://assets.leetcode.com/uploads/2020/01/16/find_the_city_02.png)

**Input:** n = 5, edges = [[0,1,2],[0,4,8],[1,2,3],[1,4,2],[2,3,1],[3,4,1]], distanceThreshold = 2
**Output:** 0
**Explanation:** The figure above describes the graph. 
The neighboring cities at a distanceThreshold = 2 for each city are:
City 0 -> [City 1] 
City 1 -> [City 0, City 4] 
City 2 -> [City 3, City 4] 
City 3 -> [City 2, City 4]
City 4 -> [City 1, City 2, City 3] 
The city 0 has 1 neighboring city at a distanceThreshold = 2.

### Solution
```java
class Solution{
	public int findTheCity(int n, int[][] edges, int distanceThreshold) {  
	    List<List<int[]>>graph=new ArrayList<>();  
	    for(int i=0;i<n;i++){  
	        graph.add(new ArrayList<>());  
	    }  
	    for(int[] edge:edges){  
	        int node1=edge[0],node2=edge[1],distance=edge[2];  
	        graph.get(node1).add(new int[]{node2, distance});  
	        graph.get(node2).add(new int[]{node1, distance});  
	    }  
	    int ans=-1,minNodes=n;  
	    for(int i=0;i<n;i++){  
	        int nodes=getNeighbors(graph,i,distanceThreshold);  
	        if(nodes<=minNodes){  
	            ans=i;  
	            minNodes=nodes;  
	        }  
	    }  
	    return ans;  
	}  
	public int getNeighbors(List<List<int[]>> graph,int source,int distanceThreshold){  
	    Queue<int[]>minHeap=new PriorityQueue<>((a,b)->a[0]-b[0]);  
	    Set<Integer> visited=new HashSet<>();  
	    minHeap.add(new int[]{0,source});  
	    while(!minHeap.isEmpty()){  
	        int[] top=minHeap.poll();  
	        int distance=top[0],currNode=top[1];  
	        if(visited.add(currNode)){  
	            for(int[] neighbor:graph.get(currNode)){  
	                int distanceFromSource=neighbor[1]+distance;  
	                if(distanceFromSource<=distanceThreshold){  
	                    minHeap.add(new int[]{distanceFromSource,neighbor[0]});  
	                }  
	            }  
	        }  
	    }  
	    return visited.size()-1;  
	}
}
```

### Explanation
1. **Graph Representation**:
    
    - Convert the input edges into an adjacency list representation for the graph.
2. **Initialize Variables**:
    
    - Initialize variables `ans` to store the result city with the smallest number of neighbors within the distance threshold.
    - Initialize `minNodes` to store the minimum number of neighbors found.
3. **Iterate Over Each City**:
    
    - For each city (from 0 to n-1), calculate the number of neighbors within the distance threshold by calling `getNeighbors`.
4. **Compare Neighbor Counts**:
    
    - If the number of neighbors for the current city is less than or equal to `minNodes`, update `ans` with the current city and `minNodes` with the current neighbor count.
5. **Return Result**:
    
    - After iterating through all cities, return `ans` which now holds the city with the smallest number of neighbors within the distance threshold.

**Helper Method - `getNeighbors`**:

1. **Priority Queue for Dijkstra's Algorithm**:
    
    - Use a priority queue (min-heap) to implement Dijkstra's algorithm for finding the shortest paths from the source city to all other cities.
2. **Visited Set**:
    
    - Maintain a set of visited cities to avoid processing the same city multiple times.
3. **Process Cities**:
    
    - While the priority queue is not empty, extract the city with the smallest distance.
    - If this city has not been visited, mark it as visited and check its neighbors.
    - For each neighbor, calculate the distance from the source city and if it is within the threshold, add it to the priority queue.
4. **Count Neighbors**:
    
    - The number of visited cities (minus one to exclude the source city itself) represents the number of neighbors within the distance threshold.
