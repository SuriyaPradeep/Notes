#sorting #merge-sort #array 
25-07-2024
### Question
Given an array of integers `nums`, sort the array in ascending order and return it.

You must solve the problem **without using any built-in** functions in `O(nlog(n))` time complexity and with the smallest space complexity possible.

**Example 1:**

**Input:** nums = [5,2,3,1]
**Output:** [1,2,3,5]
**Explanation:** After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).

**Example 2:**

**Input:** nums = [5,1,1,2,0,0]
**Output:** [0,0,1,1,2,5]
**Explanation:** Note that the values of nums are not necessairly unique.


### Solution
```java
class Solution{
	public int[] sortArray(int[] nums) {  
	    mergeSort(nums,0,nums.length-1);  
	    return  nums;  
	}  
	public void mergeSort(int[] nums,int start,int end){  
	    if(start<end){  
	        int mid=(start+end)/2;  
	        mergeSort(nums,start,mid);  
	        mergeSort(nums,mid+1,end);  
	        merge(nums,start,mid,end);  
	    }  
	}  
	public void merge(int[] nums,int start,int mid,int end){  
	    int n1=mid-start+1;  
	    int n2=end-mid;  
	    int[] arr1=Arrays.copyOfRange(nums,start,mid+1);  
	    int[] arr2=Arrays.copyOfRange(nums,mid+1,end+1);  
	    int left=0,right=0,k=start;  
	    while(left<n1 && right<n2){  
	        if(arr1[left]<=arr2[right]){  
	            nums[k++]=arr1[left++];  
	        }else{  
	            nums[k++]=arr2[right++];  
	        }  
	    }  
	    while(left<n1){  
	        nums[k++]=arr1[left++];  
	    }  
	    while(right<n2){  
	        nums[k++]=arr2[right++];  
	    }  
	}
}
```

### Explanation
 `sortArray` Method

1. Calls `mergeSort` to initiate the sorting process.
2. Returns the sorted array.

`mergeSort` Method

1. **Base Case**: If `start >= end`, return (array is already sorted).
2. **Recursive Case**:
    - Find the middle point: `mid = (start + end) / 2`.
    - Recursively sort the left half: `mergeSort(nums, start, mid)`.
    - Recursively sort the right half: `mergeSort(nums, mid + 1, end)`.
    - Merge the two sorted halves: `merge(nums, start, mid, end)`.

`merge` Method

1. Create two temporary arrays:
    - `arr1` for elements from `start` to `mid`.
    - `arr2` for elements from `mid + 1` to `end`.
2. Merge these two arrays back into the original array:
    - Use two pointers to compare elements from both arrays.
    - Place the smaller element into the original array.
3. Copy any remaining elements from `arr1` and `arr2` back to the original array.

**Summary**

- **Divide**: Recursively split the array into halves until each subarray contains a single element.
- **Conquer**: Recursively sort each subarray.
- **Combine**: Merge the sorted subarrays to produce the sorted array.